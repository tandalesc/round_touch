#include "SimDisplay.h"
#include <cstdio>

// --- Globals ---
static SDL_Window *g_window = nullptr;
static SDL_Renderer *g_renderer = nullptr;
static SDL_Texture *g_framebuffer = nullptr;
static SDL_Texture *g_maskTexture = nullptr;
static int g_logicalW = 240;
static int g_logicalH = 240;
static bool g_dirty = false;

// --- Standard Adafruit GFX 5x7 font (6x8 with spacing) ---
// Each character is 5 bytes, each byte is a column (LSB = top pixel)
// Characters 0x20 (space) through 0x7E (~)
static const uint8_t font5x7[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, // space
    0x00, 0x00, 0x5F, 0x00, 0x00, // !
    0x00, 0x07, 0x00, 0x07, 0x00, // "
    0x14, 0x7F, 0x14, 0x7F, 0x14, // #
    0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
    0x23, 0x13, 0x08, 0x64, 0x62, // %
    0x36, 0x49, 0x55, 0x22, 0x50, // &
    0x00, 0x05, 0x03, 0x00, 0x00, // '
    0x00, 0x1C, 0x22, 0x41, 0x00, // (
    0x00, 0x41, 0x22, 0x1C, 0x00, // )
    0x08, 0x2A, 0x1C, 0x2A, 0x08, // *
    0x08, 0x08, 0x3E, 0x08, 0x08, // +
    0x00, 0x50, 0x30, 0x00, 0x00, // ,
    0x08, 0x08, 0x08, 0x08, 0x08, // -
    0x00, 0x60, 0x60, 0x00, 0x00, // .
    0x20, 0x10, 0x08, 0x04, 0x02, // /
    0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
    0x00, 0x42, 0x7F, 0x40, 0x00, // 1
    0x42, 0x61, 0x51, 0x49, 0x46, // 2
    0x21, 0x41, 0x45, 0x4B, 0x31, // 3
    0x18, 0x14, 0x12, 0x7F, 0x10, // 4
    0x27, 0x45, 0x45, 0x45, 0x39, // 5
    0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
    0x01, 0x71, 0x09, 0x05, 0x03, // 7
    0x36, 0x49, 0x49, 0x49, 0x36, // 8
    0x06, 0x49, 0x49, 0x29, 0x1E, // 9
    0x00, 0x36, 0x36, 0x00, 0x00, // :
    0x00, 0x56, 0x36, 0x00, 0x00, // ;
    0x00, 0x08, 0x14, 0x22, 0x41, // <
    0x14, 0x14, 0x14, 0x14, 0x14, // =
    0x41, 0x22, 0x14, 0x08, 0x00, // >
    0x02, 0x01, 0x51, 0x09, 0x06, // ?
    0x32, 0x49, 0x79, 0x41, 0x3E, // @
    0x7E, 0x11, 0x11, 0x11, 0x7E, // A
    0x7F, 0x49, 0x49, 0x49, 0x36, // B
    0x3E, 0x41, 0x41, 0x41, 0x22, // C
    0x7F, 0x41, 0x41, 0x22, 0x1C, // D
    0x7F, 0x49, 0x49, 0x49, 0x41, // E
    0x7F, 0x09, 0x09, 0x01, 0x01, // F
    0x3E, 0x41, 0x41, 0x51, 0x32, // G
    0x7F, 0x08, 0x08, 0x08, 0x7F, // H
    0x00, 0x41, 0x7F, 0x41, 0x00, // I
    0x20, 0x40, 0x41, 0x3F, 0x01, // J
    0x7F, 0x08, 0x14, 0x22, 0x41, // K
    0x7F, 0x40, 0x40, 0x40, 0x40, // L
    0x7F, 0x02, 0x04, 0x02, 0x7F, // M
    0x7F, 0x04, 0x08, 0x10, 0x7F, // N
    0x3E, 0x41, 0x41, 0x41, 0x3E, // O
    0x7F, 0x09, 0x09, 0x09, 0x06, // P
    0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
    0x7F, 0x09, 0x19, 0x29, 0x46, // R
    0x46, 0x49, 0x49, 0x49, 0x31, // S
    0x01, 0x01, 0x7F, 0x01, 0x01, // T
    0x3F, 0x40, 0x40, 0x40, 0x3F, // U
    0x1F, 0x20, 0x40, 0x20, 0x1F, // V
    0x7F, 0x20, 0x18, 0x20, 0x7F, // W
    0x63, 0x14, 0x08, 0x14, 0x63, // X
    0x03, 0x04, 0x78, 0x04, 0x03, // Y
    0x61, 0x51, 0x49, 0x45, 0x43, // Z
    0x00, 0x00, 0x7F, 0x41, 0x41, // [
    0x02, 0x04, 0x08, 0x10, 0x20, // backslash
    0x41, 0x41, 0x7F, 0x00, 0x00, // ]
    0x04, 0x02, 0x01, 0x02, 0x04, // ^
    0x40, 0x40, 0x40, 0x40, 0x40, // _
    0x00, 0x01, 0x02, 0x04, 0x00, // `
    0x20, 0x54, 0x54, 0x54, 0x78, // a
    0x7F, 0x48, 0x44, 0x44, 0x38, // b
    0x38, 0x44, 0x44, 0x44, 0x20, // c
    0x38, 0x44, 0x44, 0x48, 0x7F, // d
    0x38, 0x54, 0x54, 0x54, 0x18, // e
    0x08, 0x7E, 0x09, 0x01, 0x02, // f
    0x08, 0x14, 0x54, 0x54, 0x3C, // g
    0x7F, 0x08, 0x04, 0x04, 0x78, // h
    0x00, 0x44, 0x7D, 0x40, 0x00, // i
    0x20, 0x40, 0x44, 0x3D, 0x00, // j
    0x00, 0x7F, 0x10, 0x28, 0x44, // k
    0x00, 0x41, 0x7F, 0x40, 0x00, // l
    0x7C, 0x04, 0x18, 0x04, 0x78, // m
    0x7C, 0x08, 0x04, 0x04, 0x78, // n
    0x38, 0x44, 0x44, 0x44, 0x38, // o
    0x7C, 0x14, 0x14, 0x14, 0x08, // p
    0x08, 0x14, 0x14, 0x18, 0x7C, // q
    0x7C, 0x08, 0x04, 0x04, 0x08, // r
    0x48, 0x54, 0x54, 0x54, 0x20, // s
    0x04, 0x3F, 0x44, 0x40, 0x20, // t
    0x3C, 0x40, 0x40, 0x20, 0x7C, // u
    0x1C, 0x20, 0x40, 0x20, 0x1C, // v
    0x3C, 0x40, 0x30, 0x40, 0x3C, // w
    0x44, 0x28, 0x10, 0x28, 0x44, // x
    0x0C, 0x50, 0x50, 0x50, 0x3C, // y
    0x44, 0x64, 0x54, 0x4C, 0x44, // z
    0x00, 0x08, 0x36, 0x41, 0x00, // {
    0x00, 0x00, 0x7F, 0x00, 0x00, // |
    0x00, 0x41, 0x36, 0x08, 0x00, // }
    0x08, 0x08, 0x2A, 0x1C, 0x08, // ~
};

static void createMaskTexture() {
  // Create a texture with the round mask: transparent inside, black outside
  g_maskTexture = SDL_CreateTexture(g_renderer, SDL_PIXELFORMAT_RGBA8888,
                                    SDL_TEXTUREACCESS_STATIC, g_logicalW,
                                    g_logicalH);
  SDL_SetTextureBlendMode(g_maskTexture, SDL_BLENDMODE_BLEND);

  uint32_t *pixels = new uint32_t[g_logicalW * g_logicalH];
  int cx = g_logicalW / 2;
  int cy = g_logicalH / 2;
  int r2 = cx * cx;

  for (int y = 0; y < g_logicalH; y++) {
    for (int x = 0; x < g_logicalW; x++) {
      int dx = x - cx;
      int dy = y - cy;
      if (dx * dx + dy * dy > r2) {
        pixels[y * g_logicalW + x] = 0x000000FF; // black, fully opaque (RGBA8888)
      } else {
        pixels[y * g_logicalW + x] = 0x00000000; // fully transparent
      }
    }
  }

  SDL_UpdateTexture(g_maskTexture, nullptr, pixels, g_logicalW * sizeof(uint32_t));
  delete[] pixels;
}

void SimDisplay::init(int windowWidth, int windowHeight, int logicalWidth,
                      int logicalHeight) {
  g_logicalW = logicalWidth;
  g_logicalH = logicalHeight;

  g_window = SDL_CreateWindow("Round Touch Simulator", SDL_WINDOWPOS_CENTERED,
                              SDL_WINDOWPOS_CENTERED, windowWidth,
                              windowHeight, SDL_WINDOW_SHOWN);
  if (!g_window) {
    fprintf(stderr, "SDL_CreateWindow failed: %s\n", SDL_GetError());
    return;
  }

  g_renderer = SDL_CreateRenderer(g_window, -1, SDL_RENDERER_ACCELERATED);
  if (!g_renderer) {
    fprintf(stderr, "SDL_CreateRenderer failed: %s\n", SDL_GetError());
    return;
  }

  SDL_RenderSetLogicalSize(g_renderer, logicalWidth, logicalHeight);

  // Create framebuffer texture â€” app renders into this
  g_framebuffer = SDL_CreateTexture(g_renderer, SDL_PIXELFORMAT_RGBA8888,
                                    SDL_TEXTUREACCESS_TARGET, logicalWidth,
                                    logicalHeight);

  // Point renderer at framebuffer by default so all gfx calls draw there
  SDL_SetRenderTarget(g_renderer, g_framebuffer);
  SDL_SetRenderDrawBlendMode(g_renderer, SDL_BLENDMODE_BLEND);

  // Pre-build the round mask texture (done once)
  createMaskTexture();
}

void SimDisplay::shutdown() {
  if (g_maskTexture) SDL_DestroyTexture(g_maskTexture);
  if (g_framebuffer) SDL_DestroyTexture(g_framebuffer);
  if (g_renderer) SDL_DestroyRenderer(g_renderer);
  if (g_window) SDL_DestroyWindow(g_window);
  g_maskTexture = nullptr;
  g_framebuffer = nullptr;
  g_renderer = nullptr;
  g_window = nullptr;
}

SDL_Window *SimDisplay::window() { return g_window; }
SDL_Renderer *SimDisplay::renderer() { return g_renderer; }

SDL_Color SimDisplay::rgb565ToSDL(uint16_t color) {
  uint8_t r = ((color >> 11) & 0x1F) << 3;
  uint8_t g = ((color >> 5) & 0x3F) << 2;
  uint8_t b = (color & 0x1F) << 3;
  r |= r >> 5;
  g |= g >> 6;
  b |= b >> 5;
  return {r, g, b, 255};
}

void SimDisplay::drawChar(SDL_Renderer *r, int x, int y, char c,
                          uint16_t color, uint8_t size) {
  if (c < 0x20 || c > 0x7E) return;

  SDL_Color sc = rgb565ToSDL(color);
  SDL_SetRenderDrawColor(r, sc.r, sc.g, sc.b, sc.a);

  int idx = (c - 0x20) * 5;
  for (int col = 0; col < 5; col++) {
    uint8_t line = font5x7[idx + col];
    for (int row = 0; row < 7; row++) {
      if (line & (1 << row)) {
        if (size == 1) {
          SDL_RenderDrawPoint(r, x + col, y + row);
        } else {
          SDL_Rect pixel = {x + col * (int)size, y + row * (int)size,
                            (int)size, (int)size};
          SDL_RenderFillRect(r, &pixel);
        }
      }
    }
  }
}

void SimDisplay::markDirty() { g_dirty = true; }

void SimDisplay::present() {
  // Switch to screen, blit framebuffer, overlay round mask, present
  SDL_SetRenderTarget(g_renderer, nullptr);
  SDL_SetRenderDrawColor(g_renderer, 0, 0, 0, 255);
  SDL_RenderClear(g_renderer);
  SDL_RenderCopy(g_renderer, g_framebuffer, nullptr, nullptr);
  SDL_RenderCopy(g_renderer, g_maskTexture, nullptr, nullptr);
  SDL_RenderPresent(g_renderer);

  // Switch back to framebuffer for next frame's rendering
  SDL_SetRenderTarget(g_renderer, g_framebuffer);
  g_dirty = false;
}
